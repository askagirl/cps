package consul

import (
	"os"
	"runtime"
	"sync"
	"time"

	"github.com/hashicorp/consul/api"

	log "github.com/sirupsen/logrus"

	"github.com/rapid7/cps/pkg/kv"
)

var (
	// If true there are no issues with s3.
	Up bool

	// If false the watcher could not list objects.
	// There are still probably objects in the kv
	// store so the service is still considered "Up".
	Health bool

	// Exports the config struct. Need to make export
	// the config struct itself (TODO).
	Config       config
	healthyNodes map[string][]string
)

type config struct {
	host string
}

func init() {
	Health = false
	Up = false

	log.SetFormatter(&log.JSONFormatter{})
	log.SetOutput(os.Stdout)
}

// Polls every 60 seconds, kicking off a consul sync.
func Poll(host string) {
	Config = config{
		host: host,
	}

	Sync(time.Now())

	ticker := time.NewTicker(60 * time.Second)
	quit := make(chan struct{})
	go func() {
		for {
			select {
			case <-ticker.C:
				Sync(time.Now())
			case <-quit:
				ticker.Stop()
				return
			}
		}
	}()
}

// This function connects to consul, gets a list of
// services and their health. Finally, it puts all
// healthy services into the kv store.
func Sync(t time.Time) {
	log.Print("consul sync begun")

	consulHost := Config.host
	client, err := setUpConsulClient(consulHost)
	if err != nil {
		return
	}

	services, qo, err := getServices(client)
	if err != nil {
		return
	}

	var wg sync.WaitGroup
	wg.Add(len(services))

	numCores := runtime.NumCPU()
	guard := make(chan struct{}, numCores*16)

	healthyNodes = make(map[string][]string)

	var mutex = &sync.Mutex{}

	for key := range services {
		guard <- struct{}{}
		go func(key string) {
			defer wg.Done()
			getServiceHealth(key, client, qo, mutex)
			<-guard
		}(key)
	}

	wg.Wait()

	writeProperties()

	Health = true
	Up = true

	log.Print("Consul sync is finished")
}

func setUpConsulClient(consulHost string) (*api.Client, error) {
	consulConfig := api.DefaultConfig()
	consulConfig.Address = consulHost
	consulConfig.Scheme = "http"

	client, err := api.NewClient(consulConfig)
	if err != nil {
		log.Errorf("Consul error: %v\n", err)
		return nil, err
	}

	return client, nil
}

func getServices(client *api.Client) (map[string][]string, api.QueryOptions, error) {
	catalog := client.Catalog()
	qo := api.QueryOptions{}
	services, _, err := catalog.Services(&qo)
	if err != nil {
		log.Errorf("Catalog/services error: %v", err)
		return nil, qo, err
	}

	return services, qo, nil
}

func writeProperties() {
	kv.WriteProperty("consul", healthyNodes)
}

func getServiceHealth(key string, client *api.Client, qo api.QueryOptions, m *sync.Mutex) {
	h := client.Health()
	sh, _, err := h.Service(key, "", true, &qo)
	if err != nil {
		log.Errorf("Failed to find service: %v", err)
		return
	}

	// Initialize an empty key in case no services are healthy.
	var emptyIp []string
	m.Lock()
	healthyNodes[key] = emptyIp
	m.Unlock()

	for _, element := range sh {
		as := element.Checks.AggregatedStatus()
		ip := element.Node.Address
		// log.Printf("Service health for %v is %v on %v", key, as, ip)
		if as == "passing" {
			m.Lock()
			healthyNodes[key] = append(healthyNodes[key], ip)
			m.Unlock()
		} else {
			log.Printf("Service %v is %v skipping!", key, as)
		}
	}
}
